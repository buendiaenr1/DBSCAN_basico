use ndarray::array;
use petal_neighbors::distance::Euclidean;
use petal_clustering::{Dbscan, Fit};


fn main (){
    //let points = array![[1., 2.], [2., 2.], [2., 2.3], [8., 7.], [8., 8.], [25., 80.]];
        let points=array![
    [18.0, 70.0],
    [19.0, 49.0],
    [18.0, 60.0],
    [16.0, 41.0],
    [17.0, 63.0],
    [16.0, 68.0],
    [16.0, 68.0],
    [16.0, 67.0],
    [18.0, 60.0],
    [18.0, 68.0],
    [18.0, 70.0],
    [16.0, 66.0],
    [15.0, 57.0],
    [15.0, 60.0],
    [19.0, 70.0],
    [15.0, 80.0],
    [15.0, 45.0],
    [23.0, 50.0],
    [18.0, 90.0],
    [19.0, 80.0],
    [18.0, 80.0],
    [16.0, 70.0],
    [17.0, 80.0],
    [16.0, 80.0],
    [16.0, 90.0],
    [16.0, 80.0],
    [18.0, 80.0],
    [18.0, 80.0],
    [18.0, 90.0],
    [16.0, 70.0],
    [15.0, 80.0],
    [15.0, 80.0],
    [19.0, 80.0],
    [15.0, 90.0],
    [15.0, 80.0],
    [23.0, 70.0],
    [18.0, 90.0],
    [19.0, 90.0],
    [18.0, 100.0],
    [16.0, 80.0],
    [17.0, 80.0],
    [16.0, 120.0],
    [16.0, 110.0],
    [16.0, 90.0],
    [18.0, 90.0],
    [18.0, 100.0],
    [18.0, 100.0],
    [16.0, 80.0],
    [15.0, 110.0],
    [15.0, 90.0],
    [19.0, 100.0],
    [15.0, 100.0],
    [15.0, 100.0],
    [23.0, 90.0],
    [18.0, 100.0],
    [19.0, 90.0],
    [18.0, 100.0],
    [16.0, 80.0],
    [17.0, 90.0],
    [16.0, 120.0],
    [16.0, 120.0],
    [16.0, 90.0],
    [18.0, 90.0],
    [18.0, 100.0],
    [18.0, 110.0],
    [16.0, 100.0],
    [15.0, 110.0],
    [15.0, 90.0],
    [19.0, 100.0],
    [15.0, 110.0],
    [15.0, 120.0],
    [23.0, 90.0],
    [18.0, 140.0],
    [19.0, 130.0],
    [18.0, 130.0],
    [16.0, 90.0],
    [17.0, 120.0],
    [16.0, 150.0],
    [16.0, 160.0],
    [16.0, 150.0],
    [18.0, 110.0],
    [18.0, 160.0],
    [18.0, 130.0],
    [16.0, 130.0],
    [15.0, 140.0],
    [15.0, 110.0],
    [19.0, 110.0],
    [15.0, 150.0],
    [15.0, 150.0],
    [23.0, 100.0],
    [18.0, 180.0],
    [19.0, 180.0],
    [18.0, 180.0],
    [16.0, 210.0],
    [17.0, 200.0],
    [16.0, 180.0],
    [16.0, 190.0],
    [16.0, 180.0],
    [18.0, 200.0],
    [18.0, 170.0],
    [18.0, 200.0],
    [16.0, 190.0],
    [15.0, 220.0],
    [15.0, 200.0],
    [19.0, 160.0],
    [15.0, 180.0],
    [15.0, 170.0],
    [23.0, 180.0],
    [18.0, 140.0],
    [19.0, 100.0],
    [18.0, 140.0],
    [16.0, 120.0],
    [17.0, 100.0],
    [16.0, 140.0],
    [16.0, 120.0],
    [16.0, 130.0],
    [18.0, 120.0],
    [18.0, 160.0],
    [18.0, 110.0],
    [16.0, 150.0],
    [15.0, 140.0],
    [15.0, 120.0],
    [19.0, 100.0],
    [15.0, 110.0],
    [15.0, 150.0],
    [23.0, 110.0],
    [18.0, 200.0],
    [19.0, 190.0],
    [18.0, 190.0],
    [16.0, 200.0],
    [17.0, 220.0],
    [16.0, 200.0],
    [16.0, 200.0],
    [16.0, 200.0],
    [18.0, 220.0],
    [18.0, 200.0],
    [18.0, 220.0],
    [16.0, 200.0],
    [15.0, 200.0],
    [15.0, 200.0],
    [19.0, 200.0],
    [15.0, 200.0],
    [15.0, 210.0],
    [23.0, 190.0]
    ];
    // parametros eps=3 radio de vecindad, minimo de puntos, metrica
    let clustering = Dbscan::new(3., 2, Euclidean::default()).fit(&points);

    println!(" Numero de clusters encontrados {}",clustering.0.len());
    
        println!(" puntos en el 0 cluster {:?}",clustering.0[&0]);
        println!(" puntos en el 1 cluster {:?}",clustering.0[&1]);
    println!("=====================================================");
    println!(" Anomalias en los puntos {:?} ",clustering.1);
    println!("=====================================================");
    let nc = clustering.0.len();
    //let mut j=0;
    for i in 0..nc {
        println!(" puntos en el {} cluster {:?} ",i,clustering.0[&i]);
        let cluster_indices = &clustering.0[&i];
        for &idx in cluster_indices {
            let point = points.row(idx);
            println!("√çndice {}: [{:.1}, {:.1}]", idx, point[0], point[1]);
        }
    }


}